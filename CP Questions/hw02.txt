# erdos numbers

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.*;


public class Main2 {

    static int nameSize;
    static int[][] matrix;
    static int[] best_so_far;
    public static void path(int i, int level)
    {
        int j;
        if(best_so_far[i]<level)
        {
            return;
        }
        best_so_far[i]=level;
        for(j=0; j<nameSize; j++)
        {
            if(matrix[i][j]==0)
            {
                continue;
            }
            path(j, level+1);
        }
    }

    public static int findIndexOf(String []list, String s)
    {
        for(int i=0; i<list.length; i++)
        {
            if(list[i].equals(s))
            {
                return i;
            }
        }
        return 0;
    }

    public static void main(String[] args) throws Exception
    {
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        int cases=Integer.parseInt(br.readLine());
        int c=1;
        while(c<=cases)
        {
            String input = br.readLine();
            StringTokenizer tokens=new StringTokenizer(input);
            int lines = Integer.parseInt(tokens.nextToken());
            int totalNames=Integer.parseInt(tokens.nextToken());
            String [] papers = new String[lines];
            String tmp;
            Set<String> set = new HashSet<String>();
            int i=0;
            int max=0;
            int size;
            while(lines>0)
            {
                papers[i]=br.readLine();
                papers[i] = papers[i].substring(0, papers[i].indexOf(':'));
                String [] s =papers[i].split(",");
                papers[i]="";
                size=0;
                for(int j=0; j<s.length; j=j+2)
                {
                    tmp=s[j].trim()+","+s[j+1];
                    papers[i]=papers[i]+tmp+"#";
                    set.add(tmp);
                    ++size;
                }
                if(size>max)
                {
                    max=size;
                }
                i++;
                --lines;
            }
            String [] questions = new String[totalNames];
            i=0;
            while(totalNames>0)
            {
                questions[i]=br.readLine();
                i++;
                --totalNames;
            }
            String [] uniqueNames = set.toArray(new String[set.size()]);
            nameSize = uniqueNames.length;
            int index= findIndexOf(uniqueNames,"Erdos, P.");
            int j;
            tmp=uniqueNames[0];
            uniqueNames[0]=uniqueNames[index];
            uniqueNames[index]=tmp;

            matrix=new int[nameSize][nameSize];
            for(i=0; i< nameSize; i++)
            {
                for(j=0; j< nameSize; j++)
                {
                    matrix[i][j]=0;
                }
            }
            int k;
            int p1,p2;
            String [] names = new String[max];
            for(i=0; i< papers.length; i++)
            {
                names=papers[i].split("#");
                for(j=0; j<names.length; j++)
                {
                    for(k=j+1; k<names.length; k++)
                    {
                        p1=findIndexOf(uniqueNames, names[j]);
                        p2=findIndexOf(uniqueNames, names[k]);
                        matrix[p1][p2]=1;
                        matrix[p2][p1]=1;
                    }
                }
            }

            best_so_far=new int[nameSize];
            for(i=0; i<nameSize; i++)
            {
                best_so_far[i]=1000;
            }
            best_so_far[0]=0;
            path(0,0);

            int erdos_score;
            System.out.println("Scenario "+c);
            for(i=0; i< questions.length; i++)
            {
                index=findIndexOf(uniqueNames,questions[i]);
                erdos_score=best_so_far[index];
                System.out.print(questions[i]+" ");
                if(erdos_score==1000)
                {
                    System.out.print("infinity");
                }
                else
                {
                    System.out.print(erdos_score);
                }
                System.out.println();
            }
            c++;
        }
    }

}


# cryptkicker

import java.util.*;
public class Main {

    static int ALPHABET=26;
    static int ASCIILetter=97;
    static int ASCIINum=33;
    public static boolean letterVisited(char wordcLetter, char wordLetter, char[] mapLetters)
    {
        for (int i = 0; i < ALPHABET; i++)
        {
            if (mapLetters[i] == wordLetter && i != (wordcLetter - ASCIILetter))
            {
                return false;
            }
        }
        return true;
    }

    public static boolean wordToword(String wordc, String eachWord, char[] mapLetters)
    {
        char[] copyMapLetters = new char[ALPHABET];
        System.arraycopy(mapLetters, 0, copyMapLetters, 0, mapLetters.length);
        for (int i = 0; i < wordc.length(); i++)
        {
            if ((mapLetters[wordc.charAt(i) - ASCIILetter] != eachWord.charAt(i) && mapLetters[wordc.charAt(i) - ASCIILetter] != '*') || !letterVisited(wordc.charAt(i), eachWord.charAt(i), mapLetters))
            {

                System.arraycopy(copyMapLetters, 0, mapLetters, 0, mapLetters.length);
                return false;
            }
            else
            {
                mapLetters[wordc.charAt(i) - ASCIILetter] = eachWord.charAt(i);
            }
        }

        return true;
    }

    public static String wordFound(String word)
    {
        if (word.length() > 0)
        {
            StringBuilder mapped = new StringBuilder();
            int pos = 0;
            HashMap<Character, Character> hashmap = new HashMap<>();
            for (int i = 0; i < word.length(); i++)
            {
                if (!hashmap.containsKey(word.charAt(i)))
                {
                    hashmap.put(word.charAt(i), (char) (ASCIINum + pos++));
                }
            }
            for (int i = 0; i < word.length(); i++)
            {
                mapped.append(hashmap.get(word.charAt(i)));
            }
            return mapped.toString();

        }
        else
        {
            return "";
        }
    }

    public static boolean mapWords(String[] vocab, String[] wordsCopy, char[] mapLetters)
    {
        ArrayList<String> options = new ArrayList<>();
        String wordc = wordsCopy[0];
        char[] copyMapLetters = new char[ALPHABET];
        System.arraycopy(mapLetters, 0, copyMapLetters, 0, copyMapLetters.length);
        for (String eachWord : vocab)
        {
            if (eachWord.length() == wordc.length() && wordFound(eachWord).equals(wordFound(wordc)))
            {
                options.add(eachWord);
            }
        }
        for (String eachWord : options)
        {
            if (wordToword(wordc, eachWord, mapLetters))
            {
                if (wordsCopy.length > 1)
                {
                    if (mapWords(vocab, Arrays.copyOfRange(wordsCopy, 1, wordsCopy.length), mapLetters))
                    {
                        return true;
                    }
                    else
                    {
                        System.arraycopy(copyMapLetters, 0, mapLetters, 0, mapLetters.length);
                    }
                }
                else
                {
                    return true;
                }
            }
        }
        return false;
    }

    public static String[] cryptKicker(String[] words, String[] vocab)
    {
        String[] afterWords = new String[words.length];
        String[] wordsCopy = Arrays.copyOf(words, words.length);
        Arrays.sort(wordsCopy, new Comparator<String>()
        {
            @Override
            public int compare(String o1, String o2)
            {
                return Integer.compare(o2.length(), o1.length());
            }
        });
        char[] mapLetters = new char[ALPHABET];
        for (int i = 0; i < ALPHABET; i++)
        {
            mapLetters[i] = '*';
        }
        if (!mapWords(vocab, wordsCopy, mapLetters))
        {
            for (int i = 0; i < ALPHABET; i++)
            {
                mapLetters[i] = '*';
            }
        }
        for (int i = 0; i < words.length; i++)
        {
            StringBuilder tmp = new StringBuilder();
            for (int j = 0; j < words[i].length(); j++)
            {
                tmp.append(mapLetters[words[i].charAt(j) - ASCIILetter]);
            }
            afterWords[i] = tmp.toString();
        }
        return afterWords;
    }

    public static void main(String[] args)
    {
        Scanner s = new Scanner(System.in);
        int size = s.nextInt();
        s.nextLine();
        String[] vocab = new String[size];
        for (int i = 0; i < vocab.length; i++)
        {
            vocab[i] = s.nextLine();
            vocab[i] = vocab[i].trim();
        }
        String sentence;
        while (s.hasNextLine())
        {
            sentence = s.nextLine();
            if (sentence.length() == 0)
            {
                System.out.println();
                continue;
            }
            String[] words = sentence.split(" ");
            for (int i = 0; i < words.length; i++)
            {
                words[i] = words[i].trim();
            }
            String[] afterWords = cryptKicker(words, vocab);
            for (int i = 0; i < afterWords.length; i++)
            {
                if (i != afterWords.length - 1)
                {
                    System.out.print(afterWords[i] + " ");
                }
                else
                {
                    System.out.println(afterWords[i]);
                }
            }
        }
    }
}

